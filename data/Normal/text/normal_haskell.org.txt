Haskell Language Get started Downloads Playground Community Documentation Donate An advanced, purely functional programming language Declarative, statically typed code. primes = filterPrime [2..] where filterPrime (p:xs) = p : filterPrime [x | x <- xs, x `mod` p /= 0] Get started Try it! Try haskell requires Javascript to be enabled. Try haskell requires cookies to be enabled. Videos Escape from the ivory tower: The Haskell journey, by Simon Peyton-Jones Functional Programming & Haskell, by Computerphile / John Hughes Past and Present of Haskell – Interview with Simon Peyton Jones Functional Programming in Haskell, by Graham Hutton What is a Monad? by Computerphile / Graham Hutton The Haskell Unfolder: Dijkstra's shortest paths, by Andres Löh and Edsko de Vries Testimonials Bellroy We've found the stability, maintainability and performance of Haskell to be exceptional and we look forward to more of that in the years to come. Bitnomial Haskell gives us huge leverage over our complex business domain while allowing us to stay nimble and innovate. The type system allows us to integrate new knowledge quickly and refactor our sizeable code base with relative ease. Calabrio At Calabrio we use Haskell to build our Customer Intelligence and Analytics Platform (Calabrio Advanced Reporting). Haskell's robust typing and semantics offer us important guarantees for our data operations and processes. CentralApp We use Haskell... Because solving complex problems well requires the best tools in the business. e-bot7 Haskell allows us to create powerful, reliable software with confidence. It allows us to detect unwanted behavior before it shows up in our production environment. finn.no FINN.no is an online classified ad site, and we use Haskell in production. It allows us to express business logic with focus on correctness and we benefit greatly from the safe and joyful refactoring Haskell brings. Fission Haskell enables Fission to build rock solid, maintainable, and performant services and tools. Foxhound Systems At Foxhound Systems, we build custom software for a variety of clients. Haskell is our first choice for building production systems because it is unrivaled in the combination of developer productivity, maintainability, reliability, and performance that it offers. Hasura Haskell is an ideal prototyping tool, when we want to build an MVP and get a prototype out as quickly as possible...Haskell lets us be precise when we need to be, and fast when we want to be. Imagine AI ImagineAI is a smart code generator written in Haskell that instantly turns your app spec into clean Django and Node source code. IOHK Smart contract systems are largely about programming languages, and when it comes to programming languages work there is no competitor to Haskell. Mercury Mercury offers banking for startups — at any size or stage. We use Haskell to meet our customers' high standards for correctness and security. NoRedInk The highest-traffic features of noredink.com are now served via Haskell. We've seen a huge performance improvement compared to what was previously doing that work as well as a massive reduction in production error rates. Scarf Haskell powers Scarf's backend, helping us move fast and not break things. It offers unparalleled maintainability, so we can quickly and safely adapt our system to the moving target of customer demands. Serokell Haskell enables us to build reliable, performant, and maintainable applications for our clients in biotech, fintech, and blockchain. Stack Builders Haskell makes it possible to maintain an EdTech platform in 23 languages for more than 70K users from one of the largest multinational financial services corporations. « » Features Statically typed Every expression in Haskell has a type which is determined at compile time. All the types composed together by function application have to match up. If they don't, the program will be rejected by the compiler. Types become not only a form of guarantee, but a language for expressing the construction of programs. Click to expand All Haskell values have a type: char = 'a' :: Char int = 123 :: Int fun = isDigit :: Char -> Bool You have to pass the right type of values to functions, or the compiler will reject the program: Type error isDigit 1 You can decode bytes into text: bytes = Crypto.Hash.SHA1.hash "hello" :: ByteString text = decodeUtf8 bytes :: Text But you cannot decode Text, which is already a vector of Unicode points: Type error doubleDecode = decodeUtf8 (decodeUtf8 bytes) Purely functional Every function in Haskell is a function in the mathematical sense (i.e., "pure"). Even side-effecting IO operations are but a description of what to do, produced by pure code. There are no statements or instructions, only expressions which cannot mutate variables (local or global) nor access state like time or random numbers. Click to expand The following function takes an integer and returns an integer. By the type it cannot do any side-effects whatsoever, it cannot mutate any of its arguments. square :: Int -> Int square x = x * x The following string concatenation is okay: "Hello: " ++ "World!" The following string concatenation is a type error: Type error "Name: " ++ getLine Because getLine has type IO String and not String, like "Name: " is. So by the type system you cannot mix and match purity with impurity. Type inference You don't have to explicitly write out every type in a Haskell program. Types will be inferred by unifying every type bidirectionally. However, you can write out types if you choose, or ask the compiler to write them for you for handy documentation. Click to expand This example has a type signature for every binding: main :: IO () main = do line :: String <- getLine print (parseDigit line) where parseDigit :: String -> Maybe Int parseDigit ((c :: Char) : _) = if isDigit c then Just (ord c - ord '0') else Nothing But you can just write: main = do line <- getLine print (parseDigit line) where parseDigit (c : _) = if isDigit c then Just (ord c - ord '0') else Nothing You can also use inference to avoid wasting time explaining what you want: do ss <- decode "[\"Hello!\",\"World!\"]" is <- decode "[1,2,3]" return (zipWith (\s i -> s ++ " " ++ show (i + 5)) ss is) => Just ["Hello! 6","World! 7"] Types give a parser specification for free, the following input is not accepted: do ss <- decode "[1,2,3]" is <- decode "[null,null,null]" return (zipWith (\s i -> s ++ " " ++ show (i + 5)) ss is) => Nothing Concurrent Haskell lends itself well to concurrent programming due to its explicit handling of effects. Its flagship compiler, GHC, comes with a high-performance parallel garbage collector and light-weight concurrency library containing a number of useful concurrency primitives and abstractions. Click to expand Easily launch threads and communicate with the standard library: main = do done <- newEmptyMVar forkIO (do putStrLn "I'm one thread!" putMVar done "Done!") second <- forkIO (do threadDelay 100000 putStrLn "I'm another thread!") killThread second msg <- takeMVar done putStrLn msg Use an asynchronous API for threads: do a1 <- async (getURL url1) a2 <- async (getURL url2) page1 <- wait a1 page2 <- wait a2 ... Atomic threading with software transactional memory: transfer :: Account -> Account -> Int -> IO () transfer from to amount = atomically (do deposit to amount withdraw from amount) Atomic transactions must be repeatable, so arbitrary IO is disabled in the type system: Type error main = atomically (putStrLn "Hello!") Lazy Functions don't evaluate their arguments. This means that programs can compose together very well, with the ability to write control constructs (such as if/else) just by writing normal functions. The purity of Haskell code makes it easy to fuse chains of functions together, allowing for performance benefits. Click to expand Define control structures easily: when p m = if p then m else return () main = do args <- getArgs when (null args) (putStrLn "No args specified!") If you notice a repeated expression pattern, like if c then t else False you can give this a name, like and c t = if c then t else False and then use it with the same effect as the original expression. Get code re-use by composing lazy functions. It's quite natural to express the any function by reusing the map and or functions: any :: (a -> Bool) -> [a] -> Bool any p = or . map p Reuse the recursion patterns in map, filter, foldr, etc. Packages Open source contribution to Haskell is very active with a wide range of packages available on the public package servers. Click to expand There are 6,954 packages freely available. Here is a sample of the most common ones: bytestring Binary data base Prelude, IO, threads network Networking text Unicode text parsec Parser library directory File/directory hspec RSpec-like tests attoparsec Fast parser monad-logger Logging persistent Database ORM template-haskell Meta-programming tar Tar archives snap Web framework time Date, time, etc. happstack Web framework yesod Web framework containers Maps, graphs, sets fsnotify Watch filesystem hint Interpret Haskell unix UNIX bindings SDL SDL binding OpenGL OpenGL graphics system criterion Benchmarking pango Text rendering cairo Cairo graphics statistics Statistical analysis gtk Gtk+ library glib GLib library test-framework Testing framework resource-pool Resource pooling conduit Streaming I/O mwc-random High-quality randoms QuickCheck Property testing stm Atomic threading blaze-html Markup generation cereal Binary parsing/printing xml XML parser/printer http-client HTTP client engine zlib zlib/gzip/raw yaml YAML parser/printer pandoc Markup conversion binary Serialization tls TLS/SSL zip-archive Zip compression warp Web server text-icu Text encodings vector Vectors async Async concurrency pipes Streaming IO scientific Arbitrary-prec. nums process Launch processes aeson JSON parser/printer dlist Difflists syb Generic prog. Sponsors Fastly's Next Generation CDN provides low latency access for all of Haskell.org's downloads and highest traffic services, including the primary Hackage server, Haskell Platform downloads, and more. Status.io powers https://status.haskell.org, and lets us easily tell you when we broke something. Equinix Metal provides compute, storage, and networking resources, powering almost all of Haskell.org in several regions around the world. DreamHost has teamed up to provide Haskell.org with redundant, scalable object-storage through their Dream Objects service. Galois provides infrastructure, funds, administrative resources and has historically hosted critical Haskell.org infrastructure, as well as helping the Haskell community at large with their work. Scarf provides data and insights on the adoption of Haskell in order to support efforts to grow the Haskell ecosystem and facilitate industry support for the language. Haskell.org Hosted and managed by Haskell.org, a 501(c)(3) non-profit. Psst! Looking for the wiki? This is the new Haskell home page! The wiki has moved to wiki.haskell.org. © 2014–2024 haskell.org Got changes to contribute to the site? Fork or comment on GitHub Hosted on