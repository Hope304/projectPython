Google Testing Blog Testing Blog Increase Test Fidelity By Avoiding Mocks Tuesday, February 27, 2024 This article was adapted from a Google Testing on the Toilet (TotT) episode. You can download a printer-friendly version of this TotT episode and post it in your office.By Andrew Trenk and Dillon BlyReplacing your code’s dependencies with mocks can make unit tests easier to write and faster to run. However, among other problems, using mocks can lead to tests that are less effective at catching bugs.The fidelity of a test refers to how closely the behavior of the test resembles the behavior of the production code. A test with higher fidelity gives you higher confidence that your code will work properly. When specifying a dependency to use in a test, prefer the highest-fidelity option. Learn more in the Test Doubles chapter of the Software Engineering at Google book.Try to use the real implementation. This provides the most fidelity, because the code in the implementation will be executed in the test. There may be tradeoffs when using a real implementation: they can be slow, non-deterministic, or difficult to instantiate (e.g., it connects to an external server). Use your judgment to decide if a real implementation is the right choice.Use a fake if you can’t use the real implementation. A fake is a lightweight implementation of an API that behaves similarly to the real implementation, e.g., an in-memory database. A fake ensures a test has high fidelity, but takes effort to write and maintain; e.g., it needs its own tests to ensure that it conforms to the behavior of the real implementation. Typically, the owner of the real implementation creates and maintains the fake. Use a mock if you can’t use the real implementation or a fake. A mock reduces fidelity, since it doesn’t execute any of the actual implementation of a dependency; its behavior is specified inline in a test (a technique known as stubbing), so it may diverge from the behavior of the real implementation. Mocks provide a basic level of confidence that your code works properly, and can be especially useful when testing a code path that is hard to trigger (e.g., an error condition such as a timeout).(Note: Although “mocks” are objects created using mocking frameworks such as Mockito or unittest.mock, the same problems will occur if you manually create your own implementation within tests.)A low-fidelity test: Dependencies are replaced with mocks. Try to avoid this.A high-fidelity test: Dependencies use real implementations or fakes. Prefer this.@Mock OrderValidator validator;@Mock PaymentProcessor processor; ...ShoppingCart cart = new ShoppingCart( validator, processor);OrderValidator validator = createValidator();PaymentProcessor processor = new FakeProcessor();...ShoppingCart cart = new ShoppingCart( validator, processor);Aim for as much fidelity as you can achieve without increasing the size of a test. At Google, tests are classified by size. Most tests should be small: they must run in a single process and must not wait on a system or event outside of their process. Increasing the fidelity of a small test is often a good choice if the test stays within these constraints. A healthy test suite also includes medium and large tests, which have higher fidelity since they can use heavyweight dependencies that aren’t feasible to use in small tests, e.g., dependencies that increase execution times or call other processes.  No comments Google Labels: Andrew Trenk , Dillon Bly , TotT Let Code Speak for Itself Tuesday, December 12, 2023 This is another post in our Code Health series. A version of this post originally appeared in Google bathrooms worldwide as a Google Testing on the Toilet episode. You can download a printer-friendly version to display in your office.by Shiva Garg and Francois AubeComments can be invaluable for understanding and maintaining a code base. But excessive comments in code can become unhelpful clutter full of extraneous and/or outdated detail. Comments that offer useless (or worse, obsolete) information hurt readability. Here are some tips to let your code speak for itself: Write comments to explain the “why” behind a certain approach in code. The comment below has two good reasons to exist: documenting non-obvious behavior and answering a question that a reader is likely to have (i.e. why doesn’t this code render directly on the screen?):// Eliminate flickering by rendering the next frame off-screen and swapping into the// visible buffer.RenderOffScreen();SwapBuffers();Use well-named identifiers to guide the reader and reduce the need for comments:// Payout should not happen if the user is// in an ineligible country.std::unordered_set<std::string> ineligible = {"Atlantis", "Utopia"};if (!ineligible.contains(country)) { Payout(user.user_id);}if (IsCountryEligibleForPayout(country)) { Payout(user.user_id); }Write function comments (a.k.a. API documentation) that describe intended meaning and purpose, not implementation details. Choose unambiguous function signatures that callers can use without reading any documentation. Don’t explain inner details that could change without affecting the contract with the caller:// Reads an input string containing either a// number of milliseconds since epoch or an// ISO 8601 date and time. Invokes the// Sole, Laces, and ToeCap APIs, then// returns an object representing the Shoe// available then or nullptr if none were.Shoe* ModelAvailableAt(char* time);// Returns the Shoe that was available for// purchase at `time`. If no model was// available, throws a runtime_error.Shoe ModelAvailableAt(time_t time);Omit comments that state the obvious. Superfluous comments increase code maintenance when code gets refactored and don’t add value, only overhead to keep these comments current:// Increment counter by 1.counter++;Learn more about writing good comments: To Comment or Not to Comment?, Best practices for writing code comments  No comments Google Labels: Code Health , Francois Aube , Shiva Garg , TotT Exceptional Exception Handling Tuesday, December 05, 2023 This is another post in our Code Health series. A version of this post originally appeared in Google bathrooms worldwide as a Google Testing on the Toilet episode. You can download a printer-friendly version to display in your office.by Yiming SunHave you ever seen huge exception-handling blocks? Here is an example in Java, although you may have seen similar problems in Python, TypeScript, Kotlin, or any language that supports exceptions.Let's assume we are calling bakePizza() to bake a pizza, and it can be overbaked, throwing a PizzaOverbakedException. class PizzaOverbakedException extends Exception {};void bakePizza () throws PizzaOverbakedException {};try { // 100+ lines of code to prepare pizza ingredients. ... bakePizza(); // Another 100+ lines of code to deliver pizza to a customer. ...} catch (Exception e) { throw new IllegalStateException(); // Root cause ignored while throwing new exception.}Here are the problems with the above code:Obscuring the logic. The method bakePizza(), is obscured by the additional lines of code of preparation and delivery, so unintended exceptions from preparation and delivery may be caught.Catching the general exception. catch (Exception e) will catch everything, despite that we might only want to handle PizzaOverbakedException here.Rethrowing a general exception, with the original exception ignored. This means that the root cause is lost - we don't know what exactly goes wrong with pizza baking while debugging.Here is a better alternative, rewritten to avoid the problems above.class PizzaOverbakedException extends Exception {};void bakePizza () throws PizzaOverbakedException {};// 100+ lines of code to prepare pizza ingredients....try { bakePizza();} catch (PizzaOverbakedException e) { // Other exceptions won’t be caught. // Rethrow a more meaningful exception; so that we know pizza is overbaked. throw new IllegalStateException(“You burned the pizza!”, e); }// Another 100+ lines of code to deliver pizza to a customer....  No comments Google Labels: Code Health , TotT , Yiming Sun Clean Up Code Cruft Tuesday, November 28, 2023 This is another post in our Code Health series. A version of this post originally appeared in Google bathrooms worldwide as a Google Testing on the Toilet episode. You can download a printer-friendly version to display in your office.By Per JacobssonThe book Clean Code discusses a camping rule that is good to keep in the back of your mind when writing code:Leave the campground cleaner than you found itSo how does that fit into software development? The thinking is this: When you make changes to code that can potentially be improved, try to make it just a little bit better.This doesn't necessarily mean you have to go out of your way to do huge refactorings. Changing something small can go a long way:Rename a variable to something more descriptive. Break apart a huge function into a few logical pieces.Fix a lint warning.Bring an outdated comment up to date.Extract duplicated lines to a function.Write a unit test for an untested function.Whatever other itch you feel like scratching.Cleaning up the small things often makes it easier to see and fix the bigger issues.But what about "If it's not broken, don't fix it"? Changing code can be risky, right? There's no obvious rule, but if you're always afraid to change your code, you have bigger problems. Cruft in code that is actively being changed is like credit card debt. Either you pay it off, or you eventually go bankrupt. Unit tests help mitigate the risk of changing code. When you're doing cleanup work, be sure there are unit tests for the things you're about to change. This may mean writing a few new ones yourself.If you’re working on a change and end up doing some minor cleanup, you can often include these cleanups in the same change. Be careful to not distract your code reviewer by adding too many unrelated cleanups. An option that works well is to send the cleanup fixes in multiple tiny changes that are small enough to just take a few seconds to review. As mentioned in the book: "Can you imagine working on a project where the code simply got better as time passed?"“Clean Code: A Handbook of Agile Software Craftsmanship” by Robert C. Martin was published in 2008.  No comments Google Labels: Code Health , Per Jacobsson , TotT    Labels  TotT 91 GTAC 61 James Whittaker 42 Misko Hevery 32 Anthony Vallone 27 Code Health 23 Patrick Copeland 23 Jobs 18 Andrew Trenk 12 C++ 11 Patrik Höglund 8 JavaScript 7 Allen Hutchison 6 George Pirocanac 6 Zhanyong Wan 6 Harry Robinson 5 Java 5 Julian Harty 5 Alberto Savoia 4 Ben Yu 4 Erik Kuefler 4 Philip Zembrod 4 Shyam Seshadri 4 Adam Bender 3 Chrome 3 Dillon Bly 3 John Thomas 3 Lesley Katzen 3 Marc Kaplan 3 Markus Clermont 3 Max Kanat-Alexander 3 Sonal Shah 3 APIs 2 Abhishek Arya 2 Alan Myrvold 2 Alek Icev 2 Android 2 April Fools 2 Chaitali Narla 2 Chris Lewis 2 Chrome OS 2 Diego Salas 2 Dori Reuveni 2 Jason Arbon 2 Jochen Wuttke 2 Kostya Serebryany 2 Marc Eaddy 2 Marko Ivanković 2 Mobile 2 Oliver Chang 2 Simon Stewart 2 Stefan Kennedy 2 Test Flakiness 2 Tony Voellm 2 WebRTC 2 Yvette Nameth 2 Zuri Kemp 2 Aaron Jacobs 1 Adam Porter 1 Adel Saoud 1 Alan Faulkner 1 Alex Eagle 1 Anantha Keesara 1 Antoine Picard 1 App Engine 1 Ari Shamash 1 Arif Sukoco 1 Benjamin Pick 1 Bob Nystrom 1 Bruce Leban 1 Carlos Arguelles 1 Carlos Israel Ortiz García 1 Cathal Weakliam 1 Christopher Semturs 1 Clay Murphy 1 Dagang Wei 1 Dan Shi 1 Dan Willemsen 1 Dave Chen 1 Dave Gladfelter 1 David Mandelberg 1 Derek Snyder 1 Diego Cavalcanti 1 Dmitry Vyukov 1 Eduardo Bravo Ortiz 1 Ekaterina Kamenskaya 1 Elliott Karpilovsky 1 Espresso 1 Felipe Sodré 1 Francois Aube 1 Google+ 1 Goran Petrovic 1 Goranka Bjedov 1 Hank Duan 1 Havard Rast Blok 1 Hongfei Ding 1 Jason Elbaum 1 Jason Huggins 1 Jay Han 1 Jeff Hoy 1 Jeff Listfield 1 Jessica Tomechak 1 Jim Reardon 1 Joe Allan Muharsky 1 Joel Hynoski 1 John Micco 1 John Penix 1 Jonathan Rockway 1 Jonathan Velasquez 1 Josh Armour 1 Julie Ralph 1 Karin Lundberg 1 Kaue Silveira 1 Kevin Bourrillion 1 Kevin Graney 1 Kirkland 1 Kurt Alfred Kluever 1 Manjusha Parvathaneni 1 Marek Kiszkis 1 Marius Latinis 1 Mark Ivey 1 Mark Manley 1 Mark Striebeck 1 Matt Lowrie 1 Meredith Whittaker 1 Michael Bachman 1 Michael Klepikov 1 Mike Aizatsky 1 Mike Wacker 1 Mona El Mahdy 1 Noel Yap 1 Palak Bansal 1 Patricia Legaspi 1 Per Jacobsson 1 Peter Arrenbrecht 1 Peter Spragins 1 Phil Norman 1 Phil Rollet 1 Pooja Gupta 1 Project Showcase 1 Radoslav Vasilev 1 Rajat Dewan 1 Rajat Jain 1 Rich Martin 1 Richard Bustamante 1 Roshan Sembacuttiaratchy 1 Ruslan Khamitov 1 Sam Lee 1 Sean Jordan 1 Sharon Zhou 1 Shiva Garg 1 Siddartha Janga 1 Simran Basi 1 Stan Chan 1 Stephen Ng 1 Tejas Shah 1 Test Analytics 1 Test Engineer 1 Tim Lyakhovetskiy 1 Tom O'Neill 1 Vojta Jína 1 Yiming Sun 1 automation 1 dead code 1 iOS 1 mutation testing 1  Archive  ▼ 2024 (1) ▼ Feb (1) Increase Test Fidelity By Avoiding Mocks ► 2023 (14) ► Dec (2) ► Nov (2) ► Oct (5) ► Sep (3) ► Aug (1) ► Apr (1) ► 2022 (2) ► Feb (2) ► 2021 (3) ► Jun (1) ► Apr (1) ► Mar (1) ► 2020 (8) ► Dec (2) ► Nov (1) ► Oct (1) ► Aug (2) ► Jul (1) ► May (1) ► 2019 (4) ► Dec (1) ► Nov (1) ► Jul (1) ► Jan (1) ► 2018 (7) ► Nov (1) ► Sep (1) ► Jul (1) ► Jun (2) ► May (1) ► Feb (1) ► 2017 (17) ► Dec (1) ► Nov (1) ► Oct (1) ► Sep (1) ► Aug (1) ► Jul (2) ► Jun (2) ► May (3) ► Apr (2) ► Feb (1) ► Jan (2) ► 2016 (15) ► Dec (1) ► Nov (2) ► Oct (1) ► Sep (2) ► Aug (1) ► Jun (2) ► May (3) ► Apr (1) ► Mar (1) ► Feb (1) ► 2015 (14) ► Dec (1) ► Nov (1) ► Oct (2) ► Aug (1) ► Jun (1) ► May (2) ► Apr (2) ► Mar (1) ► Feb (1) ► Jan (2) ► 2014 (24) ► Dec (2) ► Nov (1) ► Oct (2) ► Sep (2) ► Aug (2) ► Jul (3) ► Jun (3) ► May (2) ► Apr (2) ► Mar (2) ► Feb (1) ► Jan (2) ► 2013 (16) ► Dec (1) ► Nov (1) ► Oct (1) ► Aug (2) ► Jul (1) ► Jun (2) ► May (2) ► Apr (2) ► Mar (2) ► Jan (2) ► 2012 (11) ► Dec (1) ► Nov (2) ► Oct (3) ► Sep (1) ► Aug (4) ► 2011 (39) ► Nov (2) ► Oct (5) ► Sep (2) ► Aug (4) ► Jul (2) ► Jun (5) ► May (4) ► Apr (3) ► Mar (4) ► Feb (5) ► Jan (3) ► 2010 (37) ► Dec (3) ► Nov (3) ► Oct (4) ► Sep (8) ► Aug (3) ► Jul (3) ► Jun (2) ► May (2) ► Apr (3) ► Mar (3) ► Feb (2) ► Jan (1) ► 2009 (54) ► Dec (3) ► Nov (2) ► Oct (3) ► Sep (5) ► Aug (4) ► Jul (15) ► Jun (8) ► May (3) ► Apr (2) ► Feb (5) ► Jan (4) ► 2008 (75) ► Dec (6) ► Nov (8) ► Oct (9) ► Sep (8) ► Aug (9) ► Jul (9) ► Jun (6) ► May (6) ► Apr (4) ► Mar (4) ► Feb (4) ► Jan (2) ► 2007 (41) ► Oct (6) ► Sep (5) ► Aug (3) ► Jul (2) ► Jun (2) ► May (2) ► Apr (7) ► Mar (5) ► Feb (5) ► Jan (4) Feed Follow @googletesting Google Privacy Terms