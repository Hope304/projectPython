Snapcraft - Snaps are universal Linux packages Canonical Snapcraft Menu Close menu Snap Store About Snapcraft Learn Blog Build Docs Tutorials IoT Forum My account My published snaps My stores Account details Sign out Sign in The app store for Linux Search Close Search Snaps you may like Featured Development Games Server Featured Development Games Server View all featured snaps View all snaps Official snaps from major publishers Latest news from our blog › Loading... Learn how to snap an app in 30 minutes Choose your language: Python Pre-built apps C/C++ Go Java Node.js Electron Flutter Ruby Rust MOOS ROS ROS 2 Choose your language: Python Pre-built apps C/C++ Go Java Node.js Electron Flutter Ruby Rust MOOS ROS ROS 2 Why are snaps good for C/C++ projects? Snaps are easy to discover and install. Millions of users can browse and install snaps graphically in the Snap Store or from the command-line. Snaps install and run the same across Linux. They bundle the exact versions of your app’s dependencies. Snaps automatically update to the latest version. Four times a day, users’ systems will check for new versions and upgrade in the background. Upgrades are not disruptive. Because upgrades are not in-place, users can keep your app open as it’s upgraded in the background. Upgrades are safe. If your app fails to upgrade, users automatically roll back to the previous revision. In just a few steps, you’ll have an example C/C++ app in the Snap Store. Here's how DOSBox defines snapcraft.yaml: name: dosbox version: "0.74-svn" summary: DOS emulator description: | DOSBox is a x86 emulator with Tandy/Hercules/ […] base: core18 confinement: devmode parts: dosbox: plugin: autotools source-type: tar source: http://source.dosbox.com/dosboxsvn.tgz build-packages: - g++ - make - libsdl1.2-dev […] - libasound2-dev stage-packages: - freeglut3 - libsdl-sound1.2 - libsdl-net1.2 […] - zlib1g apps: dosbox: command: dosbox environment: "LD_LIBRARY_PATH": "$SNAP/usr/lib/$SNAPCRAFT_ARCH_TRIPLET/pulseaudio" "DISABLE_WAYLAND": "1" Show more Continue › Why are snaps good for Electron projects? Snaps are easy to discover and install. Millions of users can browse and install snaps graphically in the Snap Store or from the command-line. Snaps install and run the same across Linux. They bundle Electron and all of your app’s dependencies, be they Node modules or system libraries. Snaps automatically update to the latest version. Four times a day, users’ systems will check for new versions and upgrade in the background. Upgrades are not disruptive. Because upgrades are not in-place, users can keep your app open as it’s upgraded in the background. Upgrades are safe. If your app fails to upgrade, users automatically roll back to the previous revision. In just a few steps, you’ll have an example Electron app in the Snap Store. Here's how to use it with Electron quick-start { "name": "electron-quick-start", "version": "1.0.0", "description": "A minimal Electron application", "main": "main.js", "scripts": { "start": "electron .", "dist": "build --linux snap" }, "repository": "https://github.com/electron/electron-quick-start", "keywords": [ "Electron", "quick", "start", "tutorial", "demo" ], "author": "GitHub", "license": "CC0-1.0", "devDependencies": { "electron": "^11.2.1", "electron-builder": "^22.9.1" } } Show more Continue › Why are snaps good for Flutter projects? Snaps are easy to discover and install. Millions of users can browse and install snaps graphically in the Snap Store or from the command-line. Snaps install and run the same across Linux. They bundle the exact versions of your app’s dependencies. Snaps automatically update to the latest version. Four times a day, users’ systems will check for new versions and upgrade in the background. Upgrades are not disruptive. Because upgrades are not in-place, users can keep your app open as it’s upgraded in the background. Upgrades are safe. If your app fails to upgrade, users automatically roll back to the previous revision. In just a few steps, you’ll have an example Flutter app in the Snap Store. Here's how my-flutter-app defines snapcraft.yaml: name: my-flutter-app version: '1.0' summary: An example Flutter snap description: | An example showing how Flutter programs can be packaged as snaps. base: core22 confinement: strict grade: stable apps: my-flutter-app: command: my_flutter_app extensions: [gnome] parts: my-flutter-app: source: . plugin: flutter flutter-target: lib/main.dart Show more Continue › Why are snaps good for Go projects? Easy to discover and install by millions using the Snap Store or command-line every day Automatically updated to the latest stable version of your app Revert to the previous version if an update fails, preserving data Programming in Go makes it easy to create a zip of your app that runs across Linux, without dependencies. However, end user discovery and update management remain a challenge. Snaps fill this gap, letting you distribute a Go app in an app store experience for end users. In just a few steps, you’ll have an example Go app in the Snap Store. Here’s how Woke defines snapcraft.yaml: name: woke summary: Detect non-inclusive language in your source code description: | Creating an inclusive work environment is imperative […] version: git grade: stable base: core20 confinement: devmode apps: woke: command: bin/woke plugs: - home parts: woke: plugin: go source-type: git source: https://github.com/get-woke/woke Show more Continue › Why are snaps good for Java projects? Simplify installation instructions, regardless of distribution, to snap install myjavaapp. Directly control the delivery of automatic application updates. Distributing a Java application for Linux and reaching the widest possible audience is complicated. Typically, the user has to make sure the JRE/SDK version and their environment are configured correctly. When a Linux distribution changes the delivered JRE, this can be problematic for applications. Snapcraft ensures the correct JRE is shipped alongside the application at all times. In just a few steps, you’ll have an example Java app in the Snap Store. Here's how Freeplane defines snapcraft.yaml: name: freeplane title: Freeplane version: '1.8.1' summary: A free tool to structure and organise your information […] description: | Freeplane is a free and open source software […] base: core18 confinement: strict apps: freeplane: extensions: - gnome-3-28 command: freeplane-$SNAPCRAFT_PROJECT_VERSION/freeplane.sh environment: JAVA_HOME: $SNAP/usr/lib/jvm/java-11-openjdk-amd64 PATH: $JAVA_HOME/jre/bin:$PATH plugs: - home - network - cups-control parts: freeplane: plugin: gradle source: https://github.com/freeplane/freeplane.git source-tag: release-$SNAPCRAFT_PROJECT_VERSION gradle-version: '5.1.1' gradle-output-dir: BIN gradle-options: [binZip, -xtest, -xcreateGitTag] override-build: | snapcraftctl build unzip -o DIST/freeplane_bin-*.zip -d $SNAPCRAFT_PART_INSTALL/ build-packages: - unzip Show more Continue › Why are snaps good for MOOS projects? Bundle all the runtime requirements, including the exact version of MOOS/MOOS-IvP and system libraries you need. Directly and reliably control the delivery of application updates using existing infrastructure. Upgrades are safe. If your app fails to upgrade, users automatically roll back to the previous revision. Extremely simple creation of daemons. In just a few steps, you’ll have an example MOOS app in the Snap Store. Here's an example snapcraft.yaml that uses MOOS: name: test-moos version: '0.1' summary: MOOS Example description: | This example includes MOOSDB, the main […] base: core18 confinement: devmode parts: test-moos: source: https://github.com/themoos/core-moos/archive/v10.4.0.tar.gz plugin: cmake build-packages: [g++] apps: test-moos: command: bin/MOOSDB Show more Continue › Why are snaps good for Node.js projects? Easy to discover and install by millions using the Snap Store or command-line every day. Automatically updated to the latest stable version of your app. Revert to the previous version if an update fails, preserving data. With npm you can distribute apps to other developers, but it’s not tailored to end users. Snaps let you distribute your Node app in an app store experience. In just a few steps, you’ll have an example Node.js app in the Snap Store. Here's how wethr defines snapcraft.yaml: name: wethr version: git summary: Command line weather tool. description: | Get current weather:- $ wethr Get current weather in metric units $ wethr --metric Get current weather in imperial units $ wethr --imperial confinement: strict base: core20 apps: wethr: command: wethr parts: wethr: plugin: npm npm-node-version: 14.16.1 source: . Show more Continue › Why are snaps good for pre-built apps? Easy to discover and install by millions using the Snap Store or command-line every day Automatically updated to the latest stable version of your app Revert to the previous version if an update fails, preserving data Isolation ensures no conflicts between applications Identical behaviour across Linux distributions, even with library dependencies Distributing the Linux build of your app as a zip lets you provide one download and set of instructions for all of Linux. However, end user discovery and update management remain a challenge. Snaps fill this gap, letting you wrap your existing Linux build in an app store experience for end users. In just a few steps, you’ll have an example pre-built app in the Snap Store. How geekbench 4 defines snapcraft.yaml name: test-geekbench4 version: 4.2.0 summary: Cross-Platform Benchmark description: | Geekbench 4 measures your system's power […] confinement: devmode base: core18 parts: test-geekbench4: plugin: dump source: http://cdn.geekbench.com/Geekbench-$SNAPCRAFT_PROJECT_VERSION-Linux.tar.gz apps: test-geekbench4: command: geekbench4 Show more Continue › Why are snaps good for Python projects? Easy to discover and install by millions using the Snap Store or command-line every day Automatically updated to the latest stable version of your app Revert to the previous version if an update fails, preserving data Isolation ensures no conflicts between applications Identical behaviour across Linux distributions, even with library dependencies With PyPI you can distribute apps to other developers, but it’s not tailored to end users. Virtualenv lets you install an app’s dependencies in isolation, but it’s not automatically used for installs from PyPI. Snaps let you distribute a dependency-isolated Python app in an app store experience for end users. In just a few steps, you’ll have an example Python app in the Snap Store. Here's how liquidctl defines snapcraft.yaml: name: liquidctl summary: a status and control utility to for power, cooling and LED components description: | liquidctl is a command-line tool to monitor and control […] version: test base: core22 confinement: strict parts: liquidctl: plugin: python source: . stage-packages: - python3-usb apps: liquidctl: command: bin/liquidctl plugs: - raw-usb - hardware-observe Show more Continue › Why are snaps good for ROS projects? Bundle all the runtime requirements, including the exact version of ROS and system libraries you need. Expand the distributions supported beyond just Ubuntu. Directly and reliably control the delivery of application updates using existing infrastructure. Extremely simple creation of daemons. In just a few steps, you’ll have an example ROS app in the Snap Store. Here's an example snapcraft.yaml that uses ROS: name: ros-talker-listener version: '0.1' summary: ROS Talker/Listener Example description: | This example launches a ROS talker and listener. confinement: devmode base: core20 parts: ros-tutorials: plugin: catkin source: https://github.com/ros/ros_tutorials.git source-branch: noetic-devel catkin-packages: [roscpp_tutorials] stage-packages: - ros-noetic-roslaunch apps: ros-talker-listener: command: opt/ros/noetic/bin/roslaunch roscpp_tutorials talker_listener.launch extensions: [ros1-noetic] Show more Continue › Why are snaps good for ROS2 projects? Bundle all the runtime requirements, including the exact version of ROS and system libraries you need. Expand the distributions supported beyond just Ubuntu. Directly and reliably control the delivery of application updates using existing infrastructure. Extremely simple creation of daemons. In just a few steps, you’ll have an example ROS2 app in the Snap Store. Here's an example snapcraft.yaml that uses ROS2: name: ros2-talker-listener version: '0.1' summary: ROS2 Talker/Listener Example description: | This example launches a ROS2 talker and listener. confinement: devmode base: core22 parts: ros-demos: plugin: colcon source: https://github.com/ros2/demos.git source-branch: humble source-subdir: demo_nodes_cpp stage-packages: [ros-humble-ros2launch] apps: ros2-talker-listener: command: opt/ros/humble/bin/ros2 launch demo_nodes_cpp talker_listener.launch.py extensions: [ros2-humble] Show more Continue › Why are snaps good for Ruby projects? Bundle all the runtime requirements. Simplify installation instructions, regardless of distribution, to snap install myrubyapp. Directly control the delivery of automatic application updates. Extremely simple creation of services. Linux install instructions for Ruby applications often get complicated. To prevent modules from different Ruby applications clashing with each other, developer tools like rvm or rbenv must be used. With snapcraft, it’s one command to produce a bundle that works anywhere. In just a few steps, you’ll have an example Ruby app in the Snap Store. Here’s how Markdown lint tool uses it: name: test-mdl version: "0.5.0" summary: Markdown lint tool description: | Style checker/lint tool for markdown files confinement: devmode base: core18 parts: test-mdl: source: . plugin: ruby gems: - rake - bundler override-build: | snapcraftctl build rake install build-packages: - git apps: test-mdl: command: bin/mdl Show more Continue › Why are snaps good for Rust projects? Easy to discover and install by millions using the Snap Store or command-line every day. Automatically updated to the latest stable version of your app. Revert to the previous version if an update fails, preserving data. You can distribute your apps across Linux using a musl-enabled version of Rust, with all the dependencies satisfied. However, end user discovery and update management remain a challenge. Snaps fill this gap, letting you distribute a Rust app in an app store experience for end users. In just a few steps, you’ll have an example Rust app in the Snap Store. Here's how XSV defines snapcraft.yaml: name: test-xsv version: git summary: A fast CSV command line toolkit written in Rust description: | xsv is a command line program for indexing […] base: core18 confinement: devmode parts: test-xsv: plugin: rust source: . apps: test-xsv: command: bin/xsv Show more Continue › Testimonials “The auto-updating feature is huge” Due to the nature of our platform, we release updates more than daily which admittedly can be annoying for our users to constantly update. Therefore, having them done seamlessly in the background makes life for our users so much easier. It’s great to see snaps as the first serious attempt to try and unify the community. Jeff Dickey CLI engineer, Heroku “Starting with snaps is easy” We definitely find Snapcraft easier as it is yaml based and provides details of what artifacts are needed. Debian packaging has things that need to be followed which can be distribution specific, which creates complication. The modular containment is what appealed about snaps and [we] can see it will be a lot more flexible. Starting with snaps is easy and the resources that are provided are clean and structured which aids adoption. Lee Coward and Rakesh Singh .NET (Microsoft) “A major software discovery tool” The Snap store provides additional exposure to our tools for many of our existing and potential users. The decision to use it came quite naturally. We believe the store will be a major software discovery tool on Linux, so the more people find out about our tools naturally and install them more easily, the better for everyone. Aleksey Rostovskiy Engineer, JetBrains Showcase to millions Reach beyond your existing audience with a listing on the Snap Store, the front page for app discovery on Ubuntu and other popular distros. Browse the Snap Store Measure user growth Make data-driven decisions with active install metrics. Watch as automatic updates migrate users to your latest release. Understand your audience with geographic and version breakdowns. Back to top © 2024 Canonical Ltd. Ubuntu and Canonical are registered trademarks of Canonical Ltd. Powered by Charmed Kubernetes Join the forum, contribute to or report problems with, snapd, Snapcraft, or this site. Share on Twitter Share on Facebook Share on YouTube Terms of Service Data privacy Manage your tracker settings Service status Other functions Contact us Contact us Close